/* DO NOT EDIT THIS FILE. THIS FILE WAS GENERATED FROM flob/CellFlobFactory2.zob,
 * EDIT THAT FILE INSTEAD!
 * All changes to this file will be lost.
 */
/*   
RasterFactory2.zob
 *    
 *    Copyright (c) 2000, Ted Nelson and Tuomas Lukka
 *
 *    You may use and distribute under the terms of either the GNU Lesser
 *    General Public License, either version 2 of the license or,
 *    at your choice, any later version. Alternatively, you may use and
 *    distribute under the terms of the XPL.
 *
 *    See the LICENSE.lgpl and LICENSE.xpl files for the specific terms of 
 *    the licenses.
 *
 *    This software is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the README
 *    file for more details.
 *
 */
/*
 * Written by Tuomas Lukka, multiline by Benjamin Fallenstein
 */

package org.gzigzag;
import java.util.*;
import java.awt.*;

/** A simple cell factory that gives the cells as one-line strings.
 * Variable length is possible.
 * XXX This class is a bad copy of RasterCellFactory 1. 
 * Inheritance should be rather used, but doesn't work yet with ZObs.
 */
 
public class CellFlobFactory2 implements FlobFactory, ZOb {
public static final String rcsid = "$Id$";
    public static boolean dbg = false;
    private static final void p(String s) { if(dbg) System.out.println(s); }
    private static final void pa(String s) { System.out.println(s); }

    
    	/** The string to use to get the default cell width.  
 * <p>Default value: <PRE> "0000000000";</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	String widthstr
	    = "0000000000";	/** The default background color. 
	 * XXX Currently, because of color mixing, the foreground
	 * comes from FlobSet. This should maybe change - check later.
	 
 * <p>Default value: <PRE> Color.white;</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	Color bg
	    = Color.white;	/** The font for the default enlargement.  
 * <p>Default value: <PRE> new ScalableFont("SansSerif", Font.PLAIN, 12);</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	ScalableFont font
	    = new ScalableFont("SansSerif", Font.PLAIN, 12);	/** Whether the font changes size with the enlargement.  
 * <p>Default value: <PRE> true;</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	boolean zoomfont
	    = true;	/** Whether the font can get bigger than the default font.
	 * Ignored (or rather, doesn't have any effect) when zoomfont is false.
	 
 * <p>Default value: <PRE> true;</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	boolean enlargefont
	    = true;	/** The x and y margins
	 
 * <p>Default value: <PRE> new int[] {3, 2};</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	int[] margins
	    = new int[] {3, 2};/** UNDOCUMENTED. 
 
 * <p>Default value: <PRE> new FTextLayouter();</PRE>. 
 
 * @structparam 1 
 */ 

 public 	ZOb ftextlayouter
	    = new FTextLayouter();

    /* AUTOGENERATED! */
    static final private int fullmask = 127;

    /* AUTOGENERATED! */
    public String readParams(ZZCell start) {
	int m = 0;
	try {
	    if(start != null)
		m = readParams(start, 0);
	} catch(Throwable t) {
	    ZZLogger.exc(t);
	} finally {
	    
	}
	if((m & fullmask) != fullmask) {
	    // not all parameters present - no problem right now.
	}
	return "";
    }

    /* AUTOGENERATED! */
    private int readParams(ZZCell start, int mask) {
	ZZCell n = start;
	while(n != null) {
	    String s = n.getText();
	    // Tests autogenerated from members.
	    
	    if(s.equals("widthstr")) {
		mask |= 1;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); widthstr = s;  
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("bg")) {
		mask |= 2;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); bg = Color.decode(s);  
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("font")) {
		mask |= 4;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); 
		    {
			ZZCell c1 = c.s("d.1");
			int size = 12;
			int style = Font.PLAIN;
			if(c1 != null) {
			    size = Integer.parseInt(c1.getText());
			    ZZCell c2 = c1.s("d.1");
			    if(c2 != null) {
				String sty = c2.getText();
				if(sty.equals("BOLD"))
				    style = Font.BOLD;
				if(sty.equals("ITALIC"))
				    style = Font.ITALIC;
				else {
				    // error...
				}
			    }
			}
			font = new ScalableFont(s, style, size);
		    }
 
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("zoomfont")) {
		mask |= 8;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); 
		    if(s.equals("true")) zoomfont=true;
		    else if(s.equals("false")) zoomfont=false;
		    else { /* XXX ??? */ }
 
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("enlargefont")) {
		mask |= 16;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); 
		    if(s.equals("true")) enlargefont=true;
		    else if(s.equals("false")) enlargefont=false;
		    else { /* XXX ??? */ }
 
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("margins")) {
		mask |= 32;
		try {
		    
		    // count rank
		    int i=-1;
		    for(ZZCell c = n; c!=null; c=c.s("d.1")) i++;
		    // XXX check range
		    margins = new int[i];
		    i=0;
		    for(ZZCell c = n.s("d.1"); 
			c!=null; c=c.s("d.1")) {
			    s = c.getText();
			    margins[i] = Integer.parseInt(s); ;
			    i++;
		    }
	
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    if(s.equals("ftextlayouter")) {
		mask |= 64;
		try {
		    ZZCell c = n.s("d.1"); s = c.getText(); 
    {
    ftextlayouter = ZZDefaultSpace.readZOb(c);
    // ftextlayouter = ZZDefaultSpace.newZOb(s);
    // ftextlayouter.readParams(c.s("d.2"));

    }
 
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    { } // grab that last "else"
	    ZZCell h = n.h("d.3");
	    if(h != null && h != n) {
		// recurse
		mask |= readParams(h, mask);
	    }
	    n = n.s("d.2");
	}
	return mask;
    }



    protected Font fon(int scale) { return font.getFont(scale); }
    protected FontMetrics fonmet(int scale) {
	return font.getFontMetrics(scale);
    }
    protected int getScale(float fract) { return getScale(fract, false); }
    protected int getScale(float fract, boolean real) {
	if(!enlargefont && !real && fract>=1.0) return 1000;
	return (int)(fract*1000);
    }

    public Dimension getSize(ZZCell c, float fract) {
	String str = widthstr;
	if(c != null) str = c.getText();
	if(str == null) str = "";
	FontMetrics fm = fonmet(getScale(fract, true));
	return CellFlob1.getSize(fm, str, margins[0]*2, margins[1]*2);
    }

    public Flob makeFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, int x, int y, int d, int w, int h) {
	int scale = getScale(fract);
	Font f = fon(scale);
	FontMetrics fm = fonmet(scale);
	CellBgFlob cf = new CellBgFlob(x, y, d, w, h, c);
	Point p = cf.getPoint(1, 1);
	p =  cf.getPoint(-1, -1);
	cf.bg = bg;
	int xm = margins[0], ym = margins[1];
	addSolidColors(into, cf);

	FText ftxt = new FText(new FText.Part[] {
		new FText.CellPart(c, 0, -1, f, fm, null, null)
	});
	Rectangle rect = new Rectangle(x+xm, y+ym, w-xm-xm, h-ym-ym);

// XXX -- make this work! (shall place cursor in middle if text too long)
//	int offs = -1;
//	for(Enumeration e=ZZCursorReal.getPointers(c); e.hasMoreElements();) {
//	    int offs0 = ZZCursorReal.getOffs((ZZCell)e.nextElement());
//	    if(offs0 != ZZCursorReal.NO_OFFSET) { offs = offs0; break; }
//	}
	
	FTextLayouter ftl = (FTextLayouter)ftextlayouter;
	ftl.firstCap = false;
//	if(offs < 0)
	    ftl.place(into, ftxt, rect, d, 1, rect.y+1, 0, true, cf);
//	else
//	    ftl.place(into, ftxt, rect, d, 0, 
//		      rect.y+rect.height/2-fm.getHeight()/2, offs, true, cf);

	into.add(cf);
	return cf;
    }
    public Flob placeFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		    float fract, 
			int x, int y, int depth,
			float xfract, float yfract) {
		Dimension d = getSize(c, fract);
		return makeFlob(into, c, handleCell, fract, 
			(int)(x-xfract*d.width),
			(int)(y-yfract*d.height),
			depth, d.width, d.height);
	
    }

    public Flob centerFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, Point p, int xalign, int yalign,
		int depth, Dimension d) {
	if(d == null) d = getSize(c, fract);
	int x, y;
	x = p.x - d.width/2; y = p.y - d.height/2;
	if(xalign < 0) x = p.x - d.width;
	if(xalign > 0) x = p.x;
	if(yalign < 0) y = p.y - d.height;
	if(yalign > 0) y = p.y;
	return makeFlob(into, c, handleCell, fract, x, y, 
			depth, d.width, d.height);
    }
    public Flob centerFlob(FlobSet into, ZZCell c, ZZCell handleCell,
		float fract, Point p, int xalign, int yalign, int depth) {
	return centerFlob(into, c, handleCell, fract, p, xalign, yalign,
			  depth, null);
    }

    /** A routine to add solid background colors according to scheme 1.
     * No better place to put it right now, but this routine can be
     * called from anywhere to color the background of a cellbgflob
     * as requested.
     * Also adds line cursors, if any.
     */
    static public void addSolidColors(FlobSet into, CellBgFlob f) {
	// Special case check: Is this a cursor or a cursor's clone?
	ZZCell orig = f.c.h("d.clone", -1);
	if(orig.h("d.cursor-list", -1).s("d.cursor", -1)
	   != null) {
	    f.addColor(ZZCursorReal.getColorOrWhite(orig));
	    return; // XXX should draw line cursors!
	}
			
	ZZCell cu = f.c.s("d.cursor", 1);

	while(cu != null) {
	    Color color = ZZCursorReal.getColor(cu);
	    if(color != null) f.addColor(color);
//	    String txt = cu.getText();
//	    if(txt != null && !txt.equals("") && f instanceof CellBgFlob) {
//		try {
//		    int ind = Integer.parseInt(txt);
//		    int x = ((CellBgFlob)f).getStrX(ind);
//		    into.add(new LineDecor(x, f.y, x, f.y+f.h, 
//			Color.black, f.d));
//		} catch(NumberFormatException e) {
//		}
//	    }
	    cu = cu.s("d.cursor-list", 1);
	} 
	// XXX Does not check whose mark it is - should!
	if(f.c.s("d.mark-set", 1)!=null)
	    f.addColor(Color.red);
	
	if(f.c.s("d.clone", -1) != null)
	    f.addColor(Color.yellow);
	else if(f.c.s("d.clone", 1) != null)
	    f.addColor(new Color(255, 255, 192));

    }

}


// vim: set syntax=java :
