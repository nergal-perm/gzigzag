/* DO NOT EDIT THIS FILE. THIS FILE WAS GENERATED FROM flob/MagGrid.zob,
 * EDIT THAT FILE INSTEAD!
 * All changes to this file will be lost.
 */
/*   
MagGrid.java
 *    
 *    Copyright (c) 2000, Ted Nelson and Tuomas Lukka
 *
 *    You may use and distribute under the terms of either the GNU Lesser
 *    General Public License, either version 2 of the license or,
 *    at your choice, any later version. Alternatively, you may use and
 *    distribute under the terms of the XPL.
 *
 *    See the LICENSE.lgpl and LICENSE.xpl files for the specific terms of 
 *    the licenses.
 *
 *    This software is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the README
 *    file for more details.
 *
 */
/*
 * Written by Tuomas Lukka
 */
package org.gzigzag;
import java.awt.*;

/** A grid magnified from the center.
 */

public class MagGrid extends GridGeom implements ZOb {
public static final String rcsid = "$Id: MagGrid.zob,v 1.2 2000/10/22 09:15:09 tjl Exp $";

    
    /** UNDOCUMENTED. 
 
 * <p>Default value: <PRE> new float[] {(float)0.8, (float)0.95};</PRE>. 
 
 * @structparam 1 
 */ 

 public 
	float[] shrink // 2..2
	    = new float[] {(float)0.8, (float)0.95};
	float[] initmul // 2..2
	    = new float[] {(float)1.6, (float)1.7};
	int[] gap // 2..2
	    = new int[] {2, 2};
	/** Whether to fit all cells into view or leave
	 * edges hanging outside.
	 */
	boolean fit
	    = false;
    

    /* AUTOGENERATED! */
    static final private int fullmask = 1;

    /* AUTOGENERATED! */
    public String readParams(ZZCell start) {
	int m = 0;
	try {
	    if(start != null)
		m = readParams(start, 0);
	} catch(Throwable t) {
	    ZZLogger.exc(t);
	} finally {
	    
	}
	if((m & fullmask) != fullmask) {
	    // not all parameters present - no problem right now.
	}
	return "";
    }

    /* AUTOGENERATED! */
    private int readParams(ZZCell start, int mask) {
	ZZCell n = start;
	while(n != null) {
	    String s = n.getText();
	    // Tests autogenerated from members.
	    
	    if(s.equals("shrink")) {
		mask |= 1;
		try {
		    
		    // count rank
		    int i=-1;
		    for(ZZCell c = n; c!=null; c=c.s("d.1")) i++;
		    // XXX check range
		    shrink = new float[i];
		    i=0;
		    for(ZZCell c = n.s("d.1"); 
			c!=null; c=c.s("d.1")) {
			    s = c.getText();
			    shrink[i] = (Float.valueOf(s)).floatValue();;
			    i++;
		    }
	
		} catch(Exception e) {
		    ZZLogger.exc(e);
		}
	    } else


	    { } // grab that last "else"
	    ZZCell h = n.h("d.3");
	    if(h != null && h != n) {
		// recurse
		mask |= readParams(h, mask);
	    }
	    n = n.s("d.2");
	}
	return mask;
    }



    int[] xs;
    int[] ys;
    public Dimension setSizes(Dimension normalcell, Dimension canvas) {
	Dimension ret = new Dimension();
	ret.width = 1;
	int cur = (int)(normalcell.width * initmul[0]);
	int xw;
	for(xw = cur; xw <= canvas.width && cur > 1; xw += 2*cur+2*gap[0]) {
	    ret.width +=2;
	    cur = (int)(cur * shrink[0]);
	}
	if(fit) {
	    xw -= 2*cur+2*gap[0];
	    ret.width -= 2;
	}

	xs = new int[ret.width + 1];
	cur = (int)(normalcell.width * initmul[0]);
	xs[ret.width / 2] = cur;
	for(int i=1; i<ret.width/2+1; i++) {
	    cur = (int)(cur * shrink[0]);
	    xs[ret.width/2-i] = xs[ret.width/2+i] = cur;
	}
	cur = (canvas.width - xw)/2;
	for(int i=0; i<xs.length; i++) {
	    int l = xs[i];
	    xs[i] = cur;
	    cur += l;
	}

	cur = (int)(normalcell.height * initmul[1]);
	int yw;
	for(yw = cur; yw <= canvas.height && cur > 1; yw += 2*cur+2*gap[1]) {
	    ret.height +=2;
	    cur = (int)(cur * shrink[1]);
	}
	if(fit) {
	    yw -= 2*cur+2*gap[1];
	    ret.height -= 2;
	}

	ys = new int[ret.height + 1];
	cur = (int)(normalcell.height * initmul[1]);
	ys[ret.height / 2] = cur;
	for(int i=1; i<ret.height/2+1; i++) {
	    cur = (int)(cur * shrink[1]);
	    ys[ret.height/2-i] = ys[ret.height/2+i] = cur;
	}
	cur = (canvas.height - yw)/2;
	for(int i=0; i<ys.length; i++) {
	    int l = ys[i];
	    ys[i] = cur;
	    cur += l;
	}
	return ret;
    }
    public Rectangle getCell(int x, int y, Rectangle rect) {
	rect.x = xs[x];
	rect.y = ys[y];
	rect.width = xs[x+1]-xs[x] - gap[0];
	rect.height = ys[y+1]-ys[y] - gap[1];
	return rect;
    }
}

// vim: set syntax=java :

